# **üìå Oracle INDEX**

---

### **1Ô∏è‚É£ Full Syntax**

```sql
CREATE [UNIQUE | BITMAP] INDEX index_name
    ON table_name (column1 [ASC | DESC], column2 [ASC | DESC], ...)
    [TABLESPACE tablespace_name]
    [STORAGE (
        INITIAL n
        NEXT n
        MINEXTENTS n
        MAXEXTENTS n
    )]
    [PARALLEL n]
    [NOLOGGING];

-- Drop an index
DROP INDEX index_name;

-- Rebuild an index
ALTER INDEX index_name REBUILD;

-- Make index unusable (for maintenance)
ALTER INDEX index_name UNUSABLE;
```

---

### **2Ô∏è‚É£ Example ‚Äì Create Indexes**

#### **a) Normal (Non-Unique) Index**

```sql
CREATE INDEX idx_students_lastname
    ON students (last_name)
    TABLESPACE users
    STORAGE (
        INITIAL 50K
        NEXT 50K
        MINEXTENTS 1
        MAXEXTENTS 5
    );
```

#### **b) Unique Index**

```sql
CREATE UNIQUE INDEX idx_courses_code
    ON courses (course_code)
    TABLESPACE users;
```

*(A unique index is automatically created if you define a `UNIQUE` constraint.)*

#### **c) Composite Index (Multiple Columns)**

```sql
CREATE INDEX idx_students_name
    ON students (last_name, first_name);
```

---

### **3Ô∏è‚É£ Explanation**

* **`CREATE INDEX`** ‚Üí creates the index.
* **`UNIQUE`** ‚Üí ensures all indexed values are unique.
* **`BITMAP`** ‚Üí for columns with low cardinality (few unique values).
* **`TABLESPACE`** ‚Üí stores the index in a specific tablespace (default is same as table).
* **`STORAGE`** ‚Üí sets extent allocation (educational purpose in modern Oracle).
* **`ASC`/`DESC`** ‚Üí allows sorting optimization (rarely needed in basic indexes).

---

### **4Ô∏è‚É£ Usage in SQL / PL/SQL**

Indexes are **used automatically** by Oracle‚Äôs optimizer when you query:

```sql
SELECT *
FROM students
WHERE last_name = 'Smith';
```

If an index exists on `last_name`, Oracle can fetch rows much faster.

You can **force index usage** (for learning only):

```sql
SELECT /*+ INDEX(s idx_students_lastname) */
       *
FROM students s
WHERE last_name = 'Smith';
```

---

### **5Ô∏è‚É£ Checking / Managing Indexes**

**View all indexes for current user:**

```sql
SELECT index_name, table_name, uniqueness, tablespace_name
FROM user_indexes;
```

**View indexed columns:**

```sql
SELECT index_name, column_name, column_position
FROM user_ind_columns
WHERE table_name = 'STUDENTS';
```

**See if Oracle used an index in a query:**

```sql
EXPLAIN PLAN FOR
SELECT * FROM students WHERE last_name = 'Smith';

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

---

In Oracle, when you **create an index**, you don‚Äôt need to explicitly call it in your query.
Oracle‚Äôs **optimizer automatically decides** whether to use the index or not (based on statistics, query type, and table size).

But you can still **see or force index usage** if needed.

---

### ‚úÖ Example 1: Automatic index usage

Suppose you have:

```sql
create index idx_movies_title on movies(title);
```

Now run:

```sql
select * 
from movies 
where title = 'Inception';
```

üëâ Oracle will check `idx_movies_title` and use it if it‚Äôs faster than a full table scan.

---

### ‚úÖ Example 2: Index on foreign key

```sql
create index idx_tickets_customer on tickets(customer_id);
```

Now query:

```sql
select * 
from tickets 
where customer_id = 1;
```

üëâ Oracle uses `idx_tickets_customer` to fetch customer‚Äôs tickets quickly.

---

### ‚úÖ Example 3: Forcing Oracle to use an index (with hint)

```sql
select /*+ index(m idx_movies_title) */ * 
from movies m
where title = 'Inception';
```

üëâ The `/*+ index(...) */` hint tells Oracle **use this index**.

---

### ‚úÖ Example 4: Checking if Oracle used an index

```sql
explain plan for
select * from movies where title = 'Inception';

select * from table(dbms_xplan.display);
```

üëâ Output will show if the index `IDX_MOVIES_TITLE` was used.

---

‚ö° **Rule of Thumb**:

* Use indexes on columns in `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`.
* Oracle will decide automatically; you don‚Äôt write `use index` in normal queries.

---