# **üìå Analytical Functions in Oracle SQL**

---

## **1Ô∏è‚É£ What Are Analytical Functions?**

Analytical (or window) functions perform **calculations across a set of rows related to the current row**, **without grouping the results into one row per group**.

üìå Key parts:

* **Function** ‚Äî e.g., `SUM()`, `AVG()`, `RANK()`
* **OVER()** ‚Äî defines the **window** (set of rows) the function works on
* **PARTITION BY** ‚Äî divides data into groups (like `GROUP BY`)
* **ORDER BY** ‚Äî defines the sequence of rows in each partition

---

## **2Ô∏è‚É£ Basic Syntax**

```sql
SELECT column1,
       ANALYTIC_FUNCTION(column2) 
       OVER (PARTITION BY colX ORDER BY colY) AS alias
FROM table_name;
```

---

## **3Ô∏è‚É£ Categories of Analytical Functions**

### **A) Ranking Functions**

1. **`ROW_NUMBER()`** ‚Äì assigns a unique number to each row.
2. **`RANK()`** ‚Äì ranks rows; same values get the same rank (gaps exist).
3. **`DENSE_RANK()`** ‚Äì like `RANK()`, but without gaps.
4. **`NTILE(n)`** ‚Äì divides rows into `n` equal buckets.

üìå Example:

```sql
SELECT student_id, marks,
       RANK() OVER (ORDER BY marks DESC) AS rank_pos,
       DENSE_RANK() OVER (ORDER BY marks DESC) AS dense_rank_pos,
       ROW_NUMBER() OVER (ORDER BY marks DESC) AS row_num
FROM students;
```

---

### **B) Aggregate Functions as Analytics**

You can use **`SUM()`**, **`AVG()`**, **`COUNT()`**, **`MAX()`**, etc., with `OVER()` to keep **detail rows**.

üìå Example ‚Äî running total of sales:

```sql
SELECT order_id, order_date, amount,
       SUM(amount) OVER (ORDER BY order_date) AS running_total
FROM orders;
```

---

### **C) Windowing Clauses**

Defines the **range of rows** for the calculation.

Options:

* `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` ‚Äî cumulative sum.
* `ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING` ‚Äî sliding window.

üìå Example:

```sql
SELECT order_id, amount,
       SUM(amount) OVER (
           ORDER BY order_id
           ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
       ) AS cumulative_sum
FROM orders;
```

---

### **D) Value Functions**

1. **`LAG(column, offset)`** ‚Äì value from previous row.
2. **`LEAD(column, offset)`** ‚Äì value from next row.
3. **`FIRST_VALUE(column)`** ‚Äì first value in partition.
4. **`LAST_VALUE(column)`** ‚Äì last value in partition.

üìå Example ‚Äî compare current sales with previous:

```sql
SELECT order_id, amount,
       LAG(amount) OVER (ORDER BY order_id) AS prev_amount,
       amount - LAG(amount) OVER (ORDER BY order_id) AS diff
FROM orders;
```

---

### **E) Statistical Functions**

* `PERCENT_RANK()`
* `CUME_DIST()`
* `RATIO_TO_REPORT()`

üìå Example:

```sql
SELECT emp_id, salary,
       ROUND(RATIO_TO_REPORT(salary) OVER (), 4) AS salary_ratio
FROM employees;
```

---

## **4Ô∏è‚É£ PARTITION BY Example**

`PARTITION BY` works like `GROUP BY` for analytics ‚Äî but keeps all rows.

üìå Example ‚Äî rank students **per department**:

```sql
SELECT student_id, department, marks,
       RANK() OVER (PARTITION BY department ORDER BY marks DESC) AS dept_rank
FROM students;
```

---

## **5Ô∏è‚É£ Why Use Analytical Functions Instead of GROUP BY?**

| Feature               | GROUP BY             | Analytical Functions             |
| --------------------- | -------------------- | -------------------------------- |
| Output rows           | One row per group    | All rows kept                    |
| Multiple calculations | Limited              | Multiple functions over same set |
| Performance           | Good for aggregation | Good for reporting & dashboards  |

---

## **6Ô∏è‚É£ Performance Tips**

* Index the columns in `PARTITION BY` and `ORDER BY`.
* Use only necessary windowing to reduce computation.
* Avoid unnecessary sorts inside `OVER()`.

---