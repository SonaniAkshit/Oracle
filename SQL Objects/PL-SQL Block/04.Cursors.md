# **üìå What is a Cursor?**

In Oracle, a **cursor** is a pointer to the **context area** ‚Äî a memory location where the result of a SQL query is stored.
PL/SQL uses cursors to retrieve and manipulate rows returned by a query.

---

## **1Ô∏è‚É£ Types of Cursors**

There are **two main types**:

### **A. Implicit Cursor**

* Created automatically by Oracle for **single SQL statements** (like `INSERT`, `UPDATE`, `DELETE`, `SELECT INTO`).
* No need to declare or open them.
* Accessible using **`SQL%` attributes**:

  * `SQL%ROWCOUNT` ‚Üí Number of rows affected.
  * `SQL%FOUND` ‚Üí TRUE if at least one row is returned/affected.
  * `SQL%NOTFOUND` ‚Üí TRUE if no rows are returned/affected.
  * `SQL%ISOPEN` ‚Üí Always FALSE (implicit cursors close automatically).

**Example:**

```sql
DECLARE
    v_name students.name%TYPE;
BEGIN
    SELECT name INTO v_name
    FROM students
    WHERE student_id = 1;

    DBMS_OUTPUT.PUT_LINE('Student Name: ' || v_name);
    DBMS_OUTPUT.PUT_LINE('Rows Fetched: ' || SQL%ROWCOUNT);
END;
/
```

---

### **B. Explicit Cursor**

* Declared by the programmer for queries that return **more than one row**.
* Allows row-by-row processing.
* You **must** declare, open, fetch, and close it.

---

## **2Ô∏è‚É£ Explicit Cursor Workflow**

1. **Declare** ‚Üí Define the cursor with a SELECT statement.
2. **Open** ‚Üí Execute the query and store the result in the cursor.
3. **Fetch** ‚Üí Retrieve one row at a time into variables.
4. **Close** ‚Üí Release memory.

---

**Example:**

```sql
DECLARE
    CURSOR c_students IS
        SELECT student_id, name
        FROM students;

    v_id   students.student_id%TYPE;
    v_name students.name%TYPE;
BEGIN
    OPEN c_students; -- Step 2

    LOOP
        FETCH c_students INTO v_id, v_name; -- Step 3
        EXIT WHEN c_students%NOTFOUND;

        DBMS_OUTPUT.PUT_LINE('ID: ' || v_id || ', Name: ' || v_name);
    END LOOP;

    CLOSE c_students; -- Step 4
END;
/
```

---

## **3Ô∏è‚É£ Cursor Attributes**

For explicit cursors:

* `cursor_name%ROWCOUNT` ‚Üí Rows fetched so far.
* `cursor_name%FOUND` ‚Üí TRUE if last fetch returned a row.
* `cursor_name%NOTFOUND` ‚Üí TRUE if last fetch did not return a row.
* `cursor_name%ISOPEN` ‚Üí TRUE if cursor is currently open.

---

## **4Ô∏è‚É£ Cursor FOR Loops** (Simpler way)

You can avoid manually opening, fetching, and closing ‚Äî Oracle does it for you.

**Example:**

```sql
BEGIN
    FOR rec IN (SELECT student_id, name FROM students) LOOP
        DBMS_OUTPUT.PUT_LINE('ID: ' || rec.student_id || ', Name: ' || rec.name);
    END LOOP;
END;
/
```

---

## **5Ô∏è‚É£ Parameterized Cursors**

* Allow passing values to the cursor‚Äôs query at runtime.

**Example:**

```sql
DECLARE
    CURSOR c_student_by_course (p_course_name VARCHAR2) IS
        SELECT s.student_id, s.name
        FROM students s
        JOIN courses c ON s.student_id = c.student_id
        WHERE c.course_name = p_course_name;

    v_id   students.student_id%TYPE;
    v_name students.name%TYPE;
BEGIN
    OPEN c_student_by_course('Oracle SQL');

    LOOP
        FETCH c_student_by_course INTO v_id, v_name;
        EXIT WHEN c_student_by_course%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(v_name);
    END LOOP;

    CLOSE c_student_by_course;
END;
/
```

---

## **6Ô∏è‚É£ Ref Cursors (Dynamic Cursors)**

* Pointers to result sets that can be opened for **different queries** at runtime.
* Useful in procedures/functions when query is not known in advance.

**Example:**

```sql
DECLARE
    TYPE ref_cursor IS REF CURSOR;
    rc ref_cursor;
    v_name students.name%TYPE;
BEGIN
    OPEN rc FOR SELECT name FROM students WHERE student_id < 3;

    LOOP
        FETCH rc INTO v_name;
        EXIT WHEN rc%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(v_name);
    END LOOP;

    CLOSE rc;
END;
/
```

---

## **üîπ Summary Table**

| Cursor Type     | Use Case                          | Managed By | Multiple Rows? | Manual Open/Fetch/Close? |
| --------------- | --------------------------------- | ---------- | -------------- | ------------------------ |
| Implicit        | Single SQL statement              | Oracle     | No             | No                       |
| Explicit        | Multiple rows from fixed query    | Programmer | Yes            | Yes                      |
| Cursor FOR Loop | Multiple rows                     | Oracle     | Yes            | No                       |
| Parameterized   | Multiple rows with runtime filter | Programmer | Yes            | Yes                      |
| Ref Cursor      | Dynamic SQL result sets           | Programmer | Yes            | Yes                      |

---