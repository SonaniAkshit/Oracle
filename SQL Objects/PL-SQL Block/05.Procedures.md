# **üìå PL/SQL Procedures ‚Äì Full Deep Dive**

---

### **1Ô∏è‚É£ What is a Procedure?**

A **Procedure** in PL/SQL is a **named block** of code stored in the database that performs a specific task.
Think of it as a **function** in programming languages, but:

* It **does not have to return** a value (unlike functions).
* It can accept **parameters** (IN, OUT, IN OUT).
* It can be **stored** in the database for reuse.

---

### **2Ô∏è‚É£ Why Use Procedures?**

‚úÖ Code reusability ‚Äì write once, use many times.
‚úÖ Improved performance ‚Äì compiled & stored in DB.
‚úÖ Better security ‚Äì control access through procedures instead of direct table access.
‚úÖ Easier maintenance ‚Äì change logic in one place.

---

### **3Ô∏è‚É£ Syntax**

```sql
CREATE [OR REPLACE] PROCEDURE procedure_name
(
    param1 [IN | OUT | IN OUT] datatype,
    param2 [IN | OUT | IN OUT] datatype
)
IS
    -- Variable & constant declarations
BEGIN
    -- Executable statements
EXCEPTION
    -- Exception handling
END procedure_name;
/
```

---

### **4Ô∏è‚É£ Parameter Modes**

| Mode             | Description                                                                      |
| ---------------- | -------------------------------------------------------------------------------- |
| **IN** (default) | Passes value *into* the procedure. Value cannot be changed inside procedure.     |
| **OUT**          | Returns a value to the calling program. Value must be assigned inside procedure. |
| **IN OUT**       | Passes a value into procedure and returns an updated value.                      |

---

### **5Ô∏è‚É£ Simple Example (No Parameters)**

```sql
CREATE OR REPLACE PROCEDURE greet_student
IS
BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello Student! Welcome to Oracle PL/SQL.');
END greet_student;
/

-- Execute procedure
BEGIN
    greet_student;
END;
/
```

---

### **6Ô∏è‚É£ Example with IN Parameters**

```sql
CREATE OR REPLACE PROCEDURE get_student_details(p_id IN NUMBER)
IS
    v_name VARCHAR2(50);
BEGIN
    SELECT name INTO v_name
    FROM students
    WHERE student_id = p_id;

    DBMS_OUTPUT.PUT_LINE('Student Name: ' || v_name);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No student found with ID: ' || p_id);
END get_student_details;
/

-- Execute
BEGIN
    get_student_details(101);
END;
/
```

---

### **7Ô∏è‚É£ Example with IN & OUT Parameters**

```sql
CREATE OR REPLACE PROCEDURE get_student_name(
    p_id   IN NUMBER,
    p_name OUT VARCHAR2
)
IS
BEGIN
    SELECT name INTO p_name
    FROM students
    WHERE student_id = p_id;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        p_name := 'Not Found';
END get_student_name;
/

-- Execute
DECLARE
    v_name VARCHAR2(50);
BEGIN
    get_student_name(101, v_name);
    DBMS_OUTPUT.PUT_LINE('Name: ' || v_name);
END;
/
```

---

### **8Ô∏è‚É£ Example with IN OUT Parameters**

```sql
CREATE OR REPLACE PROCEDURE update_and_return_name(
    p_id    IN NUMBER,
    p_name IN OUT VARCHAR2
)
IS
BEGIN
    UPDATE students
    SET name = p_name
    WHERE student_id = p_id;

    SELECT name INTO p_name
    FROM students
    WHERE student_id = p_id;
END update_and_return_name;
/
```

---

### **9Ô∏è‚É£ Procedure with Exception Handling**

```sql
CREATE OR REPLACE PROCEDURE safe_divide(
    p_num1 IN NUMBER,
    p_num2 IN NUMBER
)
IS
    v_result NUMBER;
BEGIN
    v_result := p_num1 / p_num2;
    DBMS_OUTPUT.PUT_LINE('Result: ' || v_result);
EXCEPTION
    WHEN ZERO_DIVIDE THEN
        DBMS_OUTPUT.PUT_LINE('Error: Division by zero is not allowed.');
END safe_divide;
/
```

---

### **üîü Dropping a Procedure**

```sql
DROP PROCEDURE procedure_name;
```

---

### **1Ô∏è‚É£1Ô∏è‚É£ Calling a Procedure from SQL\*Plus**

```sql
EXEC procedure_name(param1, param2);
```

---

### **1Ô∏è‚É£2Ô∏è‚É£ Advanced Notes**

* Procedures can be **nested** inside other PL/SQL blocks.
* They can call **other procedures** or **functions**.
* You can **grant EXECUTE privilege** to specific users.

```sql
GRANT EXECUTE ON procedure_name TO some_user;
```

* You can debug procedures using `DBMS_OUTPUT` or PL/SQL Developer tools.
* Large projects often store **business logic** in procedures instead of the application layer for **security and performance**.

---