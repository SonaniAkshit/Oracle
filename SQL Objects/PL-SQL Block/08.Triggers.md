# **‚è≥ Triggers in PL/SQL**

---

### **1Ô∏è‚É£ What is a Trigger?**

A **trigger** is a **stored PL/SQL block** that **automatically executes** in response to a specific **event** on a **table, view, schema, or database**.

You don‚Äôt call a trigger manually ‚Äî **Oracle fires it automatically** when the event occurs.

---

### **2Ô∏è‚É£ Where Triggers are Used**

* **Auditing** changes (who changed what and when)
* **Enforcing business rules**
* **Validating data before insert/update**
* **Preventing certain operations**
* **Maintaining derived data** (e.g., updating total stock when a new sale happens)

---

### **3Ô∏è‚É£ Types of Triggers**

#### **A. By Timing**

* **BEFORE Trigger** ‚Üí Executes **before** the triggering event (can modify values before storing).
* **AFTER Trigger** ‚Üí Executes **after** the triggering event (used for logging/auditing).
* **INSTEAD OF Trigger** ‚Üí Executes **instead of** the triggering event (mainly for views).

#### **B. By Level**

* **Row-Level Trigger** ‚Üí Executes **once for each row** affected by the DML.
* **Statement-Level Trigger** ‚Üí Executes **once for the entire statement**, regardless of the number of rows.

#### **C. By Event**

* **DML Triggers** ‚Üí `INSERT`, `UPDATE`, `DELETE`
* **DDL Triggers** ‚Üí `CREATE`, `ALTER`, `DROP`
* **Database Event Triggers** ‚Üí `LOGON`, `LOGOFF`, `STARTUP`, `SHUTDOWN`

---

### **4Ô∏è‚É£ Syntax of a Basic Trigger**

```sql
CREATE OR REPLACE TRIGGER trg_before_insert_emp
BEFORE INSERT
ON employees
FOR EACH ROW  -- Row-level trigger
BEGIN
    -- Example: set hire date to sysdate if not provided
    IF :NEW.hire_date IS NULL THEN
        :NEW.hire_date := SYSDATE;
    END IF;
END;
/
```

---

### **5Ô∏è‚É£ Understanding `:NEW` and `:OLD`**

* **`:NEW`** ‚Üí Holds the new values (for `INSERT` & `UPDATE`)
* **`:OLD`** ‚Üí Holds the old values (for `UPDATE` & `DELETE`)
* Only available in **row-level triggers**.

Example:

```sql
CREATE OR REPLACE TRIGGER trg_audit_salary
AFTER UPDATE OF salary
ON employees
FOR EACH ROW
BEGIN
    INSERT INTO salary_audit (emp_id, old_salary, new_salary, changed_on)
    VALUES (:OLD.emp_id, :OLD.salary, :NEW.salary, SYSDATE);
END;
/
```

---

### **6Ô∏è‚É£ Example ‚Äì Prevent Deletion of CEO**

```sql
CREATE OR REPLACE TRIGGER trg_no_delete_ceo
BEFORE DELETE
ON employees
FOR EACH ROW
BEGIN
    IF :OLD.designation = 'CEO' THEN
        RAISE_APPLICATION_ERROR(-20001, 'You cannot delete the CEO!');
    END IF;
END;
/
```

---

### **7Ô∏è‚É£ Statement-Level Trigger Example**

```sql
CREATE OR REPLACE TRIGGER trg_after_all_updates
AFTER UPDATE
ON employees
BEGIN
    DBMS_OUTPUT.PUT_LINE('An update was performed on employees table.');
END;
/
```

* Fires **once per statement**, not per row.

---

### **8Ô∏è‚É£ DDL Trigger Example**

```sql
CREATE OR REPLACE TRIGGER trg_audit_table_changes
AFTER CREATE OR DROP OR ALTER
ON SCHEMA
BEGIN
    INSERT INTO ddl_audit (user_name, operation, object_name, change_date)
    VALUES (USER, ORA_SYSEVENT, ORA_DICT_OBJ_NAME, SYSDATE);
END;
/
```

---

### **9Ô∏è‚É£ Database Trigger Example**

```sql
CREATE OR REPLACE TRIGGER trg_logon_audit
AFTER LOGON ON DATABASE
BEGIN
    INSERT INTO login_audit (username, login_time)
    VALUES (USER, SYSDATE);
END;
/
```

---

### **üîü Best Practices & Warnings**

* ‚úÖ Use **triggers for auditing, validation, automation** ‚Äî not for core application logic.
* ‚úÖ Keep them **short & fast** (triggers slow down DML operations).
* ‚úÖ Avoid **mutating table errors** (when a trigger tries to modify the table that fired it).
* ‚úÖ Document all triggers ‚Äî they run automatically, so hidden logic can cause debugging nightmares.
* ‚ùå Don‚Äôt create too many triggers on the same table ‚Äî it becomes hard to maintain.

---

If you want, I can prepare you a **real-world trigger set** for something like
üìå *Stock Management System* ‚Äî with:

* Audit trigger
* Auto-update stock levels
* Prevent stock from going negative
  ‚Ä¶so you‚Äôll see **BEFORE**, **AFTER**, and **row-level triggers** all in one workflow.